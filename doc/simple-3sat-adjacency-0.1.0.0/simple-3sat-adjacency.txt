-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/simple-3sat-adjacency#readme</a>
@package simple-3sat-adjacency
@version 0.1.0.0

module Lib

-- | A conjunction is simply modeled as a list
newtype Conj a
Conj :: [a] -> Conj a
[runConj] :: Conj a -> [a]
evalConj :: Conj Bool -> Bool

-- | Contains <tt>[1..3]</tt> values
data Upto3 a
Upto1 :: a -> Upto3 a
Upto2 :: a -> a -> Upto3 a
Upto3 :: a -> a -> a -> Upto3 a

-- | Disjunction of up to three values
type Disj3 a = Upto3 a
evalDisj3 :: Disj3 Bool -> Bool

-- | Variables
--   
--   <pre>
--   False -&gt; a
--   True -&gt; not a
--   </pre>
newtype Var a
Var :: (Bool, a) -> Var a
[runVar] :: Var a -> (Bool, a)
evalVar :: Var Bool -> Bool

-- | 3-Sat expressions
type Sat3 a = Conj (Disj3 (Var a))
evalSat3 :: Sat3 Bool -> Bool
data Universe a
Universe :: Set a -> Set a -> Sat3 a -> [Sat3 a] -> Universe a
[vars] :: Universe a -> Set a
[completeVars] :: Universe a -> Set a
[expr] :: Universe a -> Sat3 a
[superExprs] :: Universe a -> [Sat3 a]
evalUniverse :: Universe Bool -> Bool

-- | Pick a var if one exists pickVar :: Universe a -&gt; Maybe (a,
--   Universe a)
--   
--   Pick a complete var if one exists, removing it from the <a>Set</a> of
--   <a>completeVars</a>
pickCompleteVar :: Universe a -> Maybe (a, Universe a)

-- | Partition into variables adjacent and non-adjacent to the given one
adjacentTo :: Ord a => a -> Sat3 a -> (Set a, Set a)

-- | <a>adjacentTo</a> for <a>Disj3</a>
adjacentToDisj3 :: Ord a => a -> Disj3 a -> (Set a, Set a)

-- | Partition <a>Sat3</a> into adjacent and non-adjacent subexpressions
filterAdj :: Ord a => a -> Sat3 a -> (Sat3 a, Sat3 a)

-- | <a>undefined</a>
--   
--   Choose a variable to split the <a>Universe</a> on
filterByVar :: Ord a => a -> Universe a -> Universe a

-- | A pass on adjacent variables in a 3-SAT expression:
--   
--   <pre>
--   Any vars that are not adjacent to <tt>var</tt> are removed from <tt>vars</tt>
--   
--   If <tt>var</tt> is adjacent to any <tt>var'</tt> that has an instance that is not adjacent to any instance of <tt>var</tt>,
--     then <tt>var'</tt> is removed from <tt>completeVars</tt>
--   
--   The new expression has all subexpressions that contain <tt>var</tt>
--   
--   The new <tt>superExprs'</tt> head is all subexpressions that do not contain <tt>var</tt>
--   </pre>
adjacentVarsPass :: ()

-- | <a>undefined</a>
--   
--   <pre>
--   f universe = case pickCompleteVar universe of
--     Nothing -&gt; case mergeUp universe of
--       Nothing -&gt; universe
--       Just universe' -&gt; f universe'
--     Just (var, universe') -&gt; f (filterByVar var universe')
--   </pre>
mergeUp :: Ord a => Universe a -> Maybe (Universe a)
instance GHC.Base.Functor Lib.Upto3
instance Data.Foldable.Foldable Lib.Conj
instance GHC.Base.Functor Lib.Conj
instance Data.Foldable.Foldable Lib.Upto3
